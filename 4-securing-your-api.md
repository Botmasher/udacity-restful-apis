# Securing Your API

## 1. Lesson 4 Intro
- security concerns for RESTful endpoints
- implement features for authentication and authorization from endpoints
- start by helping a few small businesses secure their web APIs

## 2. Adding Users and Logins
- concept of "user" for security and custom info
- not storing password but storing hash of user password
	- map digital data of arbitrary size to fixed-size digital data
	- one-way functions to generate hash from pwd but not the other way around
	- deterministic
	- hard to decode if compromised
- starter code https://github.com/udacity/APIs/tree/master/Lesson_4/02_Adding%20Users%20and%20Logins
1. use `passlib` like this: `from passlib.apps import custom_app_context as pwd_context`
	- `custom_app_context` is easy and based on SHA256
2. now add two new methods to `User` model:
	- `hash_password` that sets `self.password_hash` to the result of `.encrypt(password)`
		- called whenever user registers or changes password
	- `verify_password` that checks a plain password against the hash with `.verify(password, self.password)`
		- called whenever user provides credentials to be validated 
- see example code in `models.py` for lesson 4, section 2

## 3. User Registration
- make a `views.py` since the user model is in place
1. structure an endpoint so that client can post to `/users`
	- request body should be a JSON object with username and pwd
2. define the `new_user` function
	- `request.json.get()` and store the username and password in variables
	- check if they are None and `abort(400)`
	- check if the username already exists and `abort(400)`
	- create new `user = User(username=username)`
	- hash the password with `user.hash_password(password)`
	- add and commit the session changes
	- return the jsonified username and `201`
3. check to see that server responds with new user created (`HTTP/1.1 201 CREATED`)
4. note how this should be handled in live app
	- login done over a *secure* HTTPS connection
	- login in plain text is easy for a hacker to see over network
	- check out Udacity courses on security

## 4. Password Protecting a Resource
- users can now log in, but how to protect the resources they have access to?
- assume there's a resource at `/protected_resource` only made available to registered users
1. import Flask auth: `from flask_httpauth import HTTPBasicAuth`
	- basic authentication for Flask routes
	- protects endpoints decorated with `@auth.login_required`
2. give the basic auth more info to know how to validate user credentials
	- use the `@auth.verify_password` decorator and write a `verify_password` function
	- the function takes a username and password
	- the function filters for the specific user
	- the function returns `False` if there is no user or if the password does not verify
	- the function sets `g.user = user` and returns `True`
3. check what happens if you use incorrect vs correct username and password
- see the resulting updates to `views.py` in section 04 of the exercises

## 5. Quiz: Mom & Pop's Bagel Shop
- starter code for their bagel shop API
	- the `/bagels` route exposes all bagels in inventory
	- only their registered members can view this
1. help them add users to their models
	- securely store username and hashed password
2. add route for users to register
	- user makes a post request to `/users`
3. protect the bagels inventory endpoint
	- only members can view
4. use the Python tester to check that your code works

## 6. Token Based Authentication
- last time we sent username and pwd with all requests protected by `@auth.login_required`
	- very inconvenient
	- a security risk even over HTTPS
		- client must store credentials without encryption to keep resending
		- after all our password verify against hash keeps taking in a plain text pwd!
- login session object lets us store info about client state btwn requests
	- Flask creates encrypted cookie
	- browser appends to each HTTP req
- BUT our app might not always work with browser or a client that can store/transmit cookies
- so, how else can we store credentials to keep track of your state?
	- **token**: string generated by server and passed in an HTTP req
	- in this model, client exchanges credentials for an authentication token
	- in this model, client then sends token back in subsequent req
	- server can then look up token to see if client is authorized to use resource
- token expiration
	- expiration time (time at which become invalid)
	- potential to do less damage if leaked
	- server can check if it's old and reject it as invalid
- how to create tokens?
	- *straightforward*:
	1. generate random seq of chars of given length
	2. store token with user and password_hash in db
	3. store an expiration date as well (possibly)
	4. in future string comparison check it and exp as if it were plain text pwd
	- *more elaborate* (no server-side storage):
		- "cryptographically signed message" token
			- user for which token generated is encoded in token itself
			- protected against tampering with strong cryptographic signature
			- Flask uses similar approach for writing secure cookies
		- Flask can apparently do this with `itsdangerous`
- next time we'll use `itsdangerous` lib for token generation + verification

## 7. Implementing Token Based Authentication
- get started with this section's [starter code](https://github.com/udacity/APIs/tree/master/Lesson_4/07_Implementing%20Token-Based%20Authentication%20in%20Flask)
- of multiple ways to implement, instructor finds the following easy and secure:
	1. `secret_key` for signing tokens as random string of 32 chars in `models.py`
	2. new method in models called `generate_auth_token()`
		- token is encrypted dict that hides the user id
		- token also embeds expiration
	3. new method `verify_auth_token()` implements verification
		- decorated as a `@staticmethod` because user only known after token decoded
			- (so no ref to `self` or the class needed)
		- instantiate `Serializer` with `secret_key`
		- use serializer to check if `data = serializer.loads(token)`
		- output `None` if token is bad or expired
		- otherwise return the user id stored in `data['id']`
	4. new endpoint in `views.py` for client to request token
		- route `/token`
		- set `@auth.login_required`
		- definge `get_auth_token()` to have `g.user` generate auth token
		- return the jsonified token as `{'token': token.decode('ascii')}`
	5. now rework `verify_password` to pass along token
		- changing `username` argument to `username_or_token`
		- note that HTTP can send any info, it does not require it to be the actual username
		- so we'll transport the token through the same variable as username
		- verify the `username_or_token` as if it's a token
		- if it is, grab that user
		- otherwise, check username and pwd just as were doing
	6. run web server and send a test request to get your token
		- like `curl -u Usr:pwd -i -X GET http://localhost:5000/token`
		- now you can access the protected resource with the token
	- note that so far the pwd can be anything since it's not reused

## 8. Quiz: Regal Tree Foods
- help this small business by adding token-based authentication to their login system
- users don't want to log in each time they access a product
- use the Python tester file to check the app
- starter code: https://github.com/udacity/APIs/tree/master/Lesson_4/08%20_Regal%20Tree%20Foods/starter_code

## 9. OAuth 2.0
- now we have a token-based authentication system
- problems with passwords
	- it's another one users have to remember
	- we need to implement account verification and password recovery for lost passwords
	- this means users have to fill out yet another profile with yet more personal info
- enter OAuth 2.0
	- existing accounts like Google or Facebook can gain access
- looking at using this with Google

## 10. Adding OAuth 2.0 for Authentication
- imagine a client-side app logging in with Google
	1. client gets a one-time use code
	2. client sends this auth code to my server
	3. my server communicates with Google to exchange code for a token
	4. if exchange successful, I create a token to send back to client
		- now client can authenticate with my app using that token
- register app with Google to get a client ID
- refactor User model in code to take advantage of OAuth
	- there's profile info you can get from the access token
	- name, email, profile pic easily obtainable through OAuth 2.0
	- can look up users based on a unique email, so include that in the model
- add an endpoint for `/oauth/<provider>` to respond to post req
	0. run flow for provider `'google'`
	1. in that `if` branch store the `auth_code = request.json.get('auth_code')`
	2. send it off to Google in exchange for a token
		- see example code for section 10
	3. once have access token, send it off to Google and store the answer data
		- look up user based on email address
		- if user does not exist, make a new User and add and commit it
	4. make a token like `token = user.generate_auth_token(600)`
	5. send back jsonified token to client to access protected endpoints
	6. for now just display the one-time auth code
		- since we're not building a client-side app in this course
		- if we do want to build a client-side app
		- instead `@app.route(/clientOAuth)` just runs a function that `render_template('clientOAuth.html')`

## 11. 
